const crypto = require('crypto');
const SafeMessageHelper = require('../utils/safeMessageHelper');
const InstanceCoordinator = require('../utils/instanceCoordinator');

class UserController {
    constructor(database, bot) {
        this.db = database;
        this.bot = bot;
        this.processingRewards = new Set(); // Track users currently being processed
        this.coordinator = null; // Will be initialized later
    }

    // Initialize coordinator after database is ready
    async initCoordinator() {
        if (!this.coordinator) {
            this.coordinator = new InstanceCoordinator(this.db);
            await this.coordinator.init();
        }
    }

    // Generate unique referral code
    generateReferralCode() {
        return crypto.randomBytes(4).toString('hex').toUpperCase();
    }

    // Register new user or get existing
    async registerUser(userId, username, firstName, referralCode = null) {
        try {
            // Check if user already exists
            const existingUser = await this.db.get('SELECT * FROM users WHERE id = ?', [userId]);

            if (existingUser) {
                // Mark as existing user
                existingUser.isNewUser = false;
                return existingUser;
            }

            // Generate unique referral code
            let userReferralCode;
            let isUnique = false;
            while (!isUnique) {
                userReferralCode = this.generateReferralCode();
                const existing = await this.db.get('SELECT id FROM users WHERE referral_code = ?', [userReferralCode]);
                if (!existing) {
                    isUnique = true;
                }
            }

            let referrerId = null;

            // If user came from referral link
            if (referralCode) {
                const referrer = await this.db.get('SELECT id FROM users WHERE referral_code = ?', [referralCode]);
                if (referrer) {
                    referrerId = referrer.id;
                }
            }

            // Create new user
            const result = await this.db.run(
                'INSERT INTO users (id, username, first_name, referrer_id, referral_code) VALUES (?, ?, ?, ?, ?)',
                [userId, username, firstName, referrerId, userReferralCode]
            );

            // Only update referral counts for now, rewards will be processed after mandatory subscriptions
            if (referrerId) {
                await this.updateReferralCounts(referrerId);

                // Also update level 2 referrer if exists
                const referrer = await this.db.get('SELECT referrer_id FROM users WHERE id = ?', [referrerId]);
                if (referrer && referrer.referrer_id) {
                    await this.updateReferralCounts(referrer.referrer_id);
                }
            }

            // Get created user
            const newUser = await this.db.get('SELECT * FROM users WHERE id = ?', [userId]);
            // Mark as new user
            newUser.isNewUser = true;
            return newUser;
        } catch (error) {
            console.error('Error registering user:', error);
            throw error;
        }
    }

    // Add referral rewards (immediate)
    async addReferralRewards(referrerId, newUserId) {
        try {
            // Calculate boost from pets (referral_1 boost pets)
            const level1Pets = await this.db.all(`
                SELECT p.boost_multiplier, up.level
                FROM user_pets up
                JOIN pets p ON up.pet_id = p.id
                WHERE up.user_id = ? AND p.boost_type = 'referral_1'
            `, [referrerId]);

            let level1Boost = 0;
            level1Pets.forEach(pet => {
                level1Boost += pet.boost_multiplier * pet.level;
            });

            // Level 1 referral reward (3 stars base + boost)
            const baseLevel1Reward = 3;
            const finalLevel1Reward = baseLevel1Reward + level1Boost;

            await this.db.run(
                'UPDATE users SET balance = balance + ?, total_earned = total_earned + ? WHERE id = ?',
                [finalLevel1Reward, finalLevel1Reward, referrerId]
            );

            await this.db.run(
                'INSERT INTO transactions (user_id, type, amount, description) VALUES (?, ?, ?, ?)',
                [referrerId, 'referral', finalLevel1Reward, `–†–µ—Ñ–µ—Ä–∞–ª 1 —É—Ä–æ–≤–Ω—è (+${level1Boost} –±—É—Å—Ç)`]
            );

            // Check for level 2 referral
            const referrer = await this.db.get('SELECT referrer_id FROM users WHERE id = ?', [referrerId]);
            if (referrer && referrer.referrer_id) {
                // Calculate boost from pets (referral_2 boost pets)
                const level2Pets = await this.db.all(`
                    SELECT p.boost_multiplier, up.level
                    FROM user_pets up
                    JOIN pets p ON up.pet_id = p.id
                    WHERE up.user_id = ? AND p.boost_type = 'referral_2'
                `, [referrer.referrer_id]);

                let level2Boost = 0;
                level2Pets.forEach(pet => {
                    level2Boost += pet.boost_multiplier * pet.level;
                });

                // Level 2 referral reward (0.05 stars base + boost)
                const baseLevel2Reward = 0.05;
                const finalLevel2Reward = baseLevel2Reward + level2Boost;

                await this.db.run(
                    'UPDATE users SET balance = balance + ?, total_earned = total_earned + ? WHERE id = ?',
                    [finalLevel2Reward, finalLevel2Reward, referrer.referrer_id]
                );

                await this.db.run(
                    'INSERT INTO transactions (user_id, type, amount, description) VALUES (?, ?, ?, ?)',
                    [referrer.referrer_id, 'referral', finalLevel2Reward, `–†–µ—Ñ–µ—Ä–∞–ª 2 —É—Ä–æ–≤–Ω—è (+${level2Boost} –±—É—Å—Ç)`]
                );
            }
        } catch (error) {
            console.error('Error adding referral rewards:', error);
        }
    }

    // Process referral rewards after mandatory channel subscription
    async processDelayedReferralRewards(newUserId) {
        try {
            // Check if already processing this user
            if (this.processingRewards.has(newUserId)) {
                console.log(`Already processing referral rewards for user ${newUserId}`);
                return;
            }

            // Add to processing set
            this.processingRewards.add(newUserId);

            // Get the new user
            const newUser = await this.db.get('SELECT referrer_id FROM users WHERE id = ?', [newUserId]);

            if (!newUser || !newUser.referrer_id) {
                console.log(`No referrer found for user ${newUserId}`);
                this.processingRewards.delete(newUserId);
                return; // No referrer, nothing to process
            }

            // Check if we already processed rewards for this specific user
            const existingReward = await this.db.get(
                'SELECT id FROM transactions WHERE user_id = ? AND type = ? AND description LIKE ?',
                [newUser.referrer_id, 'referral', `%ID: ${newUserId}%`]
            );

            if (existingReward) {
                console.log(`Referral rewards already processed for user ${newUserId}`);
                this.processingRewards.delete(newUserId);
                return; // Already processed rewards for this specific new user
            }

            const referrerId = newUser.referrer_id;

            // Calculate boost from pets (referral_1 boost pets) –¥–ª—è –æ—Ç–ª–æ–∂–µ–Ω–Ω—ã—Ö –Ω–∞–≥—Ä–∞–¥
            const level1Pets = await this.db.all(`
                SELECT p.boost_multiplier, up.level
                FROM user_pets up
                JOIN pets p ON up.pet_id = p.id
                WHERE up.user_id = ? AND p.boost_type = 'referral_1'
            `, [referrerId]);

            let level1Boost = 0;
            level1Pets.forEach(pet => {
                level1Boost += pet.boost_multiplier * pet.level;
            });

            // Level 1 referral reward (3 stars base + boost)
            const baseLevel1Reward = 3;
            const finalLevel1Reward = baseLevel1Reward + level1Boost;

            await this.db.run(
                'UPDATE users SET balance = balance + ?, total_earned = total_earned + ? WHERE id = ?',
                [finalLevel1Reward, finalLevel1Reward, referrerId]
            );

            await this.db.run(
                'INSERT INTO transactions (user_id, type, amount, description) VALUES (?, ?, ?, ?)',
                [referrerId, 'referral', finalLevel1Reward, `–†–µ—Ñ–µ—Ä–∞–ª –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω (ID: ${newUserId}) +${level1Boost} –±—É—Å—Ç`]
            );

            // Send congratulations message to referrer
            const newUserInfo = await this.db.get('SELECT username, first_name FROM users WHERE id = ?', [newUserId]);
            const newUserName = newUserInfo ? (newUserInfo.username ? `@${newUserInfo.username}` : newUserInfo.first_name) : '–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å';

            const boostInfo = level1Boost > 0 ? ` (–±–∞–∑–æ–≤–∞—è 3 + –±—É—Å—Ç +${level1Boost} –æ—Ç –ø–∏—Ç–æ–º—Ü–µ–≤)` : '';

            try {
                await this.bot.sendMessage(referrerId, `üéâ **–ù–û–í–´–ô –†–ï–§–ï–†–ê–õ –ê–ö–¢–ò–í–ò–†–û–í–ê–ù!**

üë§ –ü–æ –≤–∞—à–µÔøΩÔøΩ —Å—Å—ã–ª–∫–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–ª—Å—è: **${newUserName}**

üí∞ **–ù–∞–≥—Ä–∞–¥–∞:** ${finalLevel1Reward.toFixed(2)} ‚≠ê${boostInfo}

üî• –ü—Ä–æ–¥–æ–ª–∂–∞–π—Ç–µ –ø—Ä–∏–≥–ª–∞—à–∞—Ç—å –¥—Ä—É–∑–µ–π –∏ –∑–∞—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å –µ—â—ë –±–æ–ª—å—à–µ!`, {
                    parse_mode: 'Markdown',
                    reply_markup: {
                        inline_keyboard: [
                            [
                                { text: 'üë• –ü—Ä–∏–≥–ª–∞—Å–∏—Ç—å –µ—â—ë', callback_data: 'menu_referral' },
                                { text: 'üêæ –ü–∏—Ç–æ–º—Ü—ã', callback_data: 'menu_pets' }
                            ],
                            [
                                { text: 'üë§ –ü—Ä–æ—Ñ–∏–ª—å', callback_data: 'menu_profile' },
                                { text: 'üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é', callback_data: 'main_menu' }
                            ]
                        ]
                    }
                });
            } catch (msgError) {
                console.log('Could not send congratulations message to referrer');
            }

            // Check for level 2 referral
            const level1Referrer = await this.db.get('SELECT referrer_id FROM users WHERE id = ?', [referrerId]);
            if (level1Referrer && level1Referrer.referrer_id) {
                // Calculate boost from pets (referral_2 boost pets)
                const level2Pets = await this.db.all(`
                    SELECT p.boost_multiplier, up.level
                    FROM user_pets up
                    JOIN pets p ON up.pet_id = p.id
                    WHERE up.user_id = ? AND p.boost_type = 'referral_2'
                `, [level1Referrer.referrer_id]);

                let level2Boost = 0;
                level2Pets.forEach(pet => {
                    level2Boost += pet.boost_multiplier * pet.level;
                });

                // Level 2 referral reward (0.05 stars base + boost)
                const baseLevel2Reward = 0.05;
                const finalLevel2Reward = baseLevel2Reward + level2Boost;

                await this.db.run(
                    'UPDATE users SET balance = balance + ?, total_earned = total_earned + ? WHERE id = ?',
                    [finalLevel2Reward, finalLevel2Reward, level1Referrer.referrer_id]
                );

                await this.db.run(
                    'INSERT INTO transactions (user_id, type, amount, description) VALUES (?, ?, ?, ?)',
                    [level1Referrer.referrer_id, 'referral', finalLevel2Reward, `–†–µ—Ñ–µ—Ä–∞–ª 2 —É—Ä–æ–≤–ΩÔøΩÔøΩ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω (ID: ${newUserId}) +${level2Boost} –±—É—Å—Ç`]
                );

                const level2BoostInfo = level2Boost > 0 ? ` (–±–∞–∑–æ–≤–∞—è 0.05 + –±—É—Å—Ç +${level2Boost} –æ—Ç –ø–∏—Ç–æ–º—Ü–µ–≤)` : '';

                // Send congratulations message to level 2 referrer
                try {
                    await this.bot.sendMessage(level1Referrer.referrer_id, `üéâ **–†–ï–§–ï–†–ê–õ 2 –£–†–û–í–ù–Ø!**

üë• –í–∞—à —Ä–µ—Ñ–µ—Ä–∞–ª –ø—Ä–∏–≤—ë–ª –¥—Ä—É–≥–∞!

üí∞ **–ù–∞–≥—Ä–∞–¥–∞:** ${finalLevel2Reward.toFixed(3)} ‚≠ê${level2BoostInfo}

üî• –ü—Ä–∏–≥–ª–∞—à–∞–π—Ç–µ –±–æ–ª—å—à–µ –¥—Ä—É–∑–µ–π –¥–ª—è —É–≤–µ–ª–∏—á–µ–Ω–∏—è –¥–æ—Ö–æ–¥–æ–≤!`, {
                        parse_mode: 'Markdown',
                        reply_markup: {
                            inline_keyboard: [
                                [{ text: '‚≠ê –ü—Ä–∏–≥–ª–∞—Å–∏—ÇÔøΩÔøΩ –¥—Ä—É–∑–µ–π', callback_data: 'menu_referral' }]
                            ]
                        }
                    });
                } catch (msgError) {
                    console.log('Could not send congratulations message to level 2 referrer');
                }
            }

        } catch (error) {
            console.error('Error processing delayed referral rewards:', error);
        } finally {
            // Always remove from processing set
            this.processingRewards.delete(newUserId);
        }
    }

    // Update referral counts
    async updateReferralCounts(userId) {
        try {
            const level1Count = await this.db.get(
                'SELECT COUNT(*) as count FROM users WHERE referrer_id = ?',
                [userId]
            );

            const level2Count = await this.db.get(
                `SELECT COUNT(*) as count FROM users u1 
                 JOIN users u2 ON u1.id = u2.referrer_id 
                 WHERE u1.referrer_id = ?`,
                [userId]
            );

            await this.db.run(
                'UPDATE users SET level1_referrals = ?, level2_referrals = ? WHERE id = ?',
                [level1Count.count, level2Count.count, userId]
            );
        } catch (error) {
            console.error('Error updating referral counts:', error);
        }
    }

    // Show user profile
    async showProfile(chatId, userId, messageId = null) {
        const lockKey = `profile_${userId}`;

        try {
            // Ensure coordinator is initialized
            if (!this.coordinator) {
                await this.initCoordinator();
            }

            // Use instance coordination to prevent multiple profile updates
            const profileData = await this.coordinator.withLock(lockKey, async () => {
                // Get all profile data atomically
                const user = await this.db.get('SELECT * FROM users WHERE id = ?', [userId]);
                if (!user) {
                    throw new Error('USER_NOT_FOUND');
                }

                // Get user pets by boost type
                const userPets = await this.db.all(`
                    SELECT p.name, p.boost_multiplier, p.boost_type, up.level
                    FROM user_pets up
                    JOIN pets p ON up.pet_id = p.id
                    WHERE up.user_id = ?
                    ORDER BY up.id ASC
                `, [userId]);

                return { user, userPets };
            });

            const { user, userPets } = profileData;

            let petsInfo = '';
            let clickBoost = 0;
            let referral1Boost = 0;
            let referral2Boost = 0;
            let taskBoost = 0;

            if (userPets.length === 0) {
                petsInfo = 'üêæ **–ü–∏—Ç–æ–º—Ü—ã:** –û—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç';
            } else {
                // Calculate boosts by type
                userPets.forEach(pet => {
                    const petBoost = pet.boost_multiplier * pet.level;
                    switch(pet.boost_type) {
                        case 'click':
                            clickBoost += petBoost;
                            break;
                        case 'referral_1':
                            referral1Boost += petBoost;
                            break;
                        case 'referral_2':
                            referral2Boost += petBoost;
                            break;
                        case 'task':
                            taskBoost += petBoost;
                            break;
                    }
                });

                const petsList = userPets.map(pet => {
                    return `${pet.name} (${pet.level} —É—Ä.)`;
                }).join(', ');
                petsInfo = `üêæ **–ê–∫—Ç–∏–≤–Ω—ã–µ –ø–∏—Ç–æ–º—Ü—ã:** ${petsList}`;
            }

            // Create boost info string
            let boostInfo = '';
            if (clickBoost > 0 || referral1Boost > 0 || referral2Boost > 0 || taskBoost > 0) {
                boostInfo = '\nüìà **–ë—É—Å—Ç—ã –æ—Ç –ø–∏—Ç–æ–º—Ü–µ–≤:**';
                if (clickBoost > 0) boostInfo += `\n‚Ä¢ –ö–ª–∏–∫–µ—Ä: +${clickBoost.toFixed(1)} ‚≠ê`;
                if (referral1Boost > 0) boostInfo += `\n‚Ä¢ –†–µ—Ñ–µ—Ä–∞–ª—ã 1 —É—Ä.: +${referral1Boost.toFixed(1)} ‚≠ê`;
                if (referral2Boost > 0) boostInfo += `\n‚Ä¢ –†–µ—Ñ–µ—Ä–∞–ª—ã 2 —É—Ä.: +${referral2Boost.toFixed(1)} ‚≠ê`;
                if (taskBoost > 0) boostInfo += `\n‚Ä¢ –ó–∞–¥–∞–Ω–∏—è: +${taskBoost.toFixed(1)} ‚≠ê`;
            }

            const profileMessage = `üë§ **–ü–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ã–π –ø—Ä–æ—Ñ–∏–ª—å**

üí∞ **–¢–µ–∫—É—â–∏–π –±–∞–ª–∞–Ω—Å:** ${user.balance.toFixed(2)} ‚≠ê
üíé **–û–±—â–∏–π –∑–∞—Ä–∞–±–æ—Ç–æ–∫:** ${user.total_earned.toFixed(2)} ‚≠ê

üë• **–†–µ—Ñ–µ—Ä–∞–ª—å–Ω–∞—è —Å–µ—Ç—å:**
‚îú –ü—Ä—è–º—ã–µ —Ä–µ—Ñ–µ—Ä–∞–ª—ã: ${user.level1_referrals} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
‚îî –†–µ—Ñ–µ—Ä–∞–ª—ã 2-–≥–æ —É—Ä–æ–≤–Ω—è: ${user.level2_referrals} –ø–æ–ªÔøΩÔøΩ–∑–æ–≤–∞—Ç–µ–ª–µ–π

${petsInfo}${boostInfo}

üîó **–ü–µ—Ä—Å–æ–Ω–∞–ª—å–Ω–∞—è —Ä–µ—Ñ–µ—Ä–∞–ª—å–Ω–∞—è —Å—Å—ã–ª–∫–∞:**
\`https://t.me/kirbystarsfarmbot?start=${user.referral_code}\`

üí° –ü–æ–¥–µ–ª–∏—Ç–µ—Å—å —Å—Å—ã–ª–∫–æ–π —Å –¥—Ä—É–∑—å—è–º–∏ –¥–ª—è –ø–æ–ªÔøΩÔøΩ—á–µ–Ω–∏—è –±–æ–Ω—É—Å–æ–≤!`;

            const keyboard = {
                inline_keyboard: [
                    [
                        { text: 'üëÜ –ö–ª–∏–∫–Ω—É—Ç—å', callback_data: 'menu_click' },
                        { text: '‚≠ê –ü—Ä–∏–≥–ª–∞—Å–∏—Ç—å –¥—Ä—É–∑–µ–π', callback_data: 'menu_referral' }
                    ],
                    [
                        { text: 'üêæ –ü–∏—Ç–æ–º—Ü—ã', callback_data: 'menu_pets' },
                        { text: 'üìã –ó–∞–¥–∞–Ω–∏—è', callback_data: 'menu_tasks' }
                    ],
                    [
                        { text: 'üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é', callback_data: 'main_menu' }
                    ]
                ]
            };

            if (messageId) {
                await SafeMessageHelper.safeEditMessage(this.bot, profileMessage, {
                    chat_id: chatId,
                    message_id: messageId,
                    parse_mode: 'Markdown',
                    reply_markup: keyboard
                });
            } else {
                await this.bot.sendMessage(chatId, profileMessage, {
                    parse_mode: 'Markdown',
                    reply_markup: keyboard
                });
            }

            console.log(`‚úÖ Profile displayed successfully for user ${userId}`);

        } catch (error) {
            console.error('Error showing profile:', error);

            if (error.message === 'USER_NOT_FOUND') {
                const errorMsg = '‚ùå –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω';
                if (messageId) {
                    await SafeMessageHelper.safeEditMessage(this.bot, errorMsg, {
                        chat_id: chatId,
                        message_id: messageId
                    });
                } else {
                    await this.bot.sendMessage(chatId, errorMsg);
                }
            } else {
                await this.bot.sendMessage(chatId, '‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –ø—Ä–æ—Ñ–∏–ª—è');
            }
        }
    }

    // Daily click system
    async dailyClick(chatId, userId, messageId = null) {
        try {
            const user = await this.db.get('SELECT * FROM users WHERE id = ?', [userId]);
            if (!user) {
                await this.bot.sendMessage(chatId, '‚ùå –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω');
                return;
            }

            const today = new Date().toDateString();
            const lastClickDate = user.last_click_date;

            if (lastClickDate === today) {
                // Calculate time until next click
                const now = new Date();
                const tomorrow = new Date(now);
                tomorrow.setDate(tomorrow.getDate() + 1);
                tomorrow.setHours(0, 0, 0, 0);

                const timeUntilReset = tomorrow.getTime() - now.getTime();
                const hoursLeft = Math.floor(timeUntilReset / (1000 * 60 * 60));
                const minutesLeft = Math.floor((timeUntilReset % (1000 * 60 * 60)) / (1000 * 60));

                const timeLeftText = hoursLeft > 0
                    ? `${hoursLeft}—á ${minutesLeft}–º`
                    : `${minutesLeft}–º`;

                const alreadyClickedMsg = `‚è∞ **–ï–∂–µ–¥–Ω–µ–≤–Ω—ã–π –±–æ–Ω—É—Å —É–∂–µ –ø–æÔøΩÔøΩ—É—á–µ–Ω**

–í—ã —É–∂–µ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–ª–∏ –µ–∂–µ–¥–Ω–µ–≤–Ω—É—é –Ω–∞–≥—Ä–∞–¥—É —Å–µ–≥–æ–¥–Ω—è.

‚è≥ **–°–ª–µ–¥—É—é—â–∏–π –∫–ª–∏–∫ —á–µ—Ä–µ–∑:** ${timeLeftText}

üí° **–°–æ–≤–µ—Ç:** –ü—Ä–∏–æ–±—Ä–µ—Ç–∏—Ç–µ –ø–∏—Ç–æ–º—Ü–µ–≤ –¥–ª—è —É–≤–µ–ª–∏—á–µ–Ω–∏—è –µ–∂–µ–¥–Ω–µ–≤–Ω—ã—Ö –Ω–∞–≥—Ä–∞–¥.`;

                const keyboard = {
                    inline_keyboard: [
                        [
                            { text: 'üêæ –ü–∏—Ç–æ–º—Ü—ã', callback_data: 'menu_pets' },
                            { text: 'üë§ –ü—Ä–æ—Ñ–∏–ª—å', callback_data: 'menu_profile' }
                        ],
                        [
                            { text: 'üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é', callback_data: 'main_menu' }
                        ]
                    ]
                };

                if (messageId) {
                    await SafeMessageHelper.safeEditMessage(this.bot,alreadyClickedMsg, {
                        chat_id: chatId,
                        message_id: messageId,
                        parse_mode: 'Markdown',
                        reply_markup: keyboard
                    });
                } else {
                    await this.bot.sendMessage(chatId, alreadyClickedMsg, {
                        parse_mode: 'Markdown',
                        reply_markup: keyboard
                    });
                }
                return;
            }

            // Calculate boost from pets (only click boost pets)
            const userPets = await this.db.all(`
                SELECT p.boost_multiplier, up.level
                FROM user_pets up
                JOIN pets p ON up.pet_id = p.id
                WHERE up.user_id = ? AND p.boost_type = 'click'
            `, [userId]);

            let totalBoost = 0; // –ò–∑–º–µ–Ω–µ–Ω–æ —Å 1 –Ω–∞ 0 –¥–ª—è –∞–¥–¥–∏—Ç–∏–≤–Ω–æ–π —Å–∏—Å—Ç–µ–º—ã
            userPets.forEach(pet => {
                totalBoost += pet.boost_multiplier * pet.level; // –ê–¥–¥–∏—Ç–∏–≤–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ –≤–º–µ—Å—Ç–æ –º—É–ª—å—Ç–∏–ø–ª–∏–∫–∞—Ç–∏–≤–Ω–æ–π
            });

            const baseReward = 0.1;
            const finalReward = baseReward + totalBoost; // –î–æ–±–∞–≤–ª—è–µ–º –±—É—Å—Ç, –∞ –Ω–µ —É–º–Ω–æ–∂–∞–µ–º

            // Update user balance and last click date
            await this.db.run(
                'UPDATE users SET balance = balance + ?, total_earned = total_earned + ?, last_click_date = ? WHERE id = ?',
                [finalReward, finalReward, today, userId]
            );

            // Log transaction
            await this.db.run(
                'INSERT INTO transactions (user_id, type, amount, description) VALUES (?, ?, ?, ?)',
                [userId, 'click', finalReward, '–ï–∂–µ–¥–ΩÔøΩÔøΩ–≤–Ω—ã–π –∫–ª–∏–∫']
            );

            const boostInfo = totalBoost > 0 ? ` (–±–∞–∑–æ–≤–∞—è ${baseReward} + –±—É—Å—Ç +${totalBoost.toFixed(1)} –æ—Ç –ø–∏—Ç–æ–º—Ü–µ–≤)` : '';

            const successMsg = `‚úÖ **–ï–∂–µ–¥–Ω–µ–≤–Ω–∞—è –Ω–∞–≥—Ä–∞–¥–∞ –ø–æ–ª—É—á–µ–Ω–∞!**

üí∞ **–ù–∞—á–∏—Å–ª–µ–Ω–æ:** ${finalReward.toFixed(3)} ‚≠ê${boostInfo}
üíé **–¢–µ–∫—É—â–∏–π –±–∞–ª–∞–Ω—Å:** ${(user.balance + finalReward).toFixed(2)} ‚≠ê

‚è∞ **–°–ª–µ–¥—É—é—â–∞—è –Ω–∞–≥—Ä–∞–¥–∞ —á–µ—Ä–µ–∑:** 24 —á–∞—Å–∞

üéØ **–£–≤–µ–ª–∏—á—å—Ç–µ ÔøΩÔøΩ–æ—Ö–æ–¥—ã:**
‚Ä¢ –ü—Ä–∏–æ–±—Ä–µ—Ç–∏—Ç–µ –ø–∏—Ç–æ–º—Ü–µ–≤ –¥–ª—è –ø–æ—Å—Ç–æ—è–Ω–Ω–æ–≥–æ –±–æ–Ω—É—Å–∞
‚Ä¢ –ü—Ä–∏–≥–ª–∞—à–∞–π—Ç–µ –¥—Ä—É–∑–µ–π –∑–∞ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –Ω–∞–≥—Ä–∞–¥—ã`;

            const keyboard = {
                inline_keyboard: [
                    [
                        { text: 'üêæ –ü–∏—Ç–æ–º—Ü—ã', callback_data: 'menu_pets' },
                        { text: '‚≠ê –†–µ—Ñ–µ—Ä–∞–ª—ã', callback_data: 'menu_referral' }
                    ],
                    [
                        { text: 'üë§ –ü—Ä–æ—Ñ–∏–ª—å', callback_data: 'menu_profile' },
                        { text: 'üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é', callback_data: 'main_menu' }
                    ]
                ]
            };

            if (messageId) {
                await SafeMessageHelper.safeEditMessage(this.bot,successMsg, {
                    chat_id: chatId,
                    message_id: messageId,
                    parse_mode: 'Markdown',
                    reply_markup: keyboard
                });
            } else {
                await this.bot.sendMessage(chatId, successMsg, {
                    parse_mode: 'Markdown',
                    reply_markup: keyboard
                });
            }

        } catch (error) {
            console.error('Error in daily click:', error);
            await this.bot.sendMessage(chatId, '‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–∏ –∫–ª–∏–∫–∞');
        }
    }

    // Get user by ID
    async getUser(userId) {
        return await this.db.get('SELECT * FROM users WHERE id = ?', [userId]);
    }

    // Update user balance
    async updateBalance(userId, amount, description = '') {
        try {
            await this.db.run(
                'UPDATE users SET balance = balance + ?, total_earned = total_earned + ? WHERE id = ?',
                [amount, amount > 0 ? amount : 0, userId]
            );

            if (amount !== 0) {
                await this.db.run(
                    'INSERT INTO transactions (user_id, type, amount, description) VALUES (?, ?, ?, ?)',
                    [userId, amount > 0 ? 'reward' : 'spend', amount, description]
                );
            }
        } catch (error) {
            console.error('Error updating balance:', error);
            throw error;
        }
    }
}

module.exports = UserController;
